// Do not edit this file; automatically generated by gulp.

/* eslint-disable */
;(function (root, factory) {
    if (typeof define === 'function' && define.amd) { // AMD
        define(['./blockly_compressed.js'], factory);
    } else if (typeof exports === 'object') { // Node.js
        module.exports = factory(require('./blockly_compressed.js'));
    } else { // Browser
        root.Blockly.Solidity = factory(root.Blockly);
    }
}(this, function (Blockly) {
    'use strict';
    Blockly.Solidity = new Blockly.Generator("Solidity");
    Blockly.Solidity.addReservedWords("break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,enum,implements,interface,let,package,private,protected,public,static,await,null,true,false,arguments," + Object.getOwnPropertyNames(Blockly.utils.global).join(","));
    Blockly.Solidity.ORDER_ATOMIC = 0;           // 0 "" ...
    Blockly.Solidity.ORDER_NEW = 1.1;            // new
    Blockly.Solidity.ORDER_MEMBER = 1.2;         // . []
    Blockly.Solidity.ORDER_FUNCTION_CALL = 2;    // ()
    Blockly.Solidity.ORDER_INCREMENT = 3;        // ++
    Blockly.Solidity.ORDER_DECREMENT = 3;        // --
    Blockly.Solidity.ORDER_BITWISE_NOT = 4.1;    // ~
    Blockly.Solidity.ORDER_UNARY_PLUS = 4.2;     // +
    Blockly.Solidity.ORDER_UNARY_NEGATION = 4.3; // -
    Blockly.Solidity.ORDER_LOGICAL_NOT = 4.4;    // !
    Blockly.Solidity.ORDER_TYPEOF = 4.5;         // typeof
    Blockly.Solidity.ORDER_VOID = 4.6;           // void
    Blockly.Solidity.ORDER_DELETE = 4.7;         // delete
    Blockly.Solidity.ORDER_DIVISION = 5.1;       // /
    Blockly.Solidity.ORDER_MULTIPLICATION = 5.2; // *
    Blockly.Solidity.ORDER_MODULUS = 5.3;        // %
    Blockly.Solidity.ORDER_SUBTRACTION = 6.1;    // -
    Blockly.Solidity.ORDER_ADDITION = 6.2;       // +
    Blockly.Solidity.ORDER_BITWISE_SHIFT = 7;    // << >> >>>
    Blockly.Solidity.ORDER_RELATIONAL = 8;       // < <= > >=
    Blockly.Solidity.ORDER_IN = 8;               // in
    Blockly.Solidity.ORDER_INSTANCEOF = 8;       // instanceof
    Blockly.Solidity.ORDER_EQUALITY = 9;         // == != === !==
    Blockly.Solidity.ORDER_BITWISE_AND = 10;     // &
    Blockly.Solidity.ORDER_BITWISE_XOR = 11;     // ^
    Blockly.Solidity.ORDER_BITWISE_OR = 12;      // |
    Blockly.Solidity.ORDER_LOGICAL_AND = 13;     // &&
    Blockly.Solidity.ORDER_LOGICAL_OR = 14;      // ||
    Blockly.Solidity.ORDER_CONDITIONAL = 15;     // ?:
    Blockly.Solidity.ORDER_ASSIGNMENT = 16;      // = += -= *= /= %= <<= >>= ...
    Blockly.Solidity.ORDER_COMMA = 17;           // ,
    Blockly.Solidity.ORDER_NONE = 99;            // (...)

    Blockly.Solidity.ORDER_OVERRIDES = [
        [Blockly.Solidity.ORDER_FUNCTION_CALL, Blockly.Solidity.ORDER_MEMBER],
        [Blockly.Solidity.ORDER_FUNCTION_CALL, Blockly.Solidity.ORDER_FUNCTION_CALL],
        [Blockly.Solidity.ORDER_MEMBER, Blockly.Solidity.ORDER_MEMBER],
        [Blockly.Solidity.ORDER_MEMBER, Blockly.Solidity.ORDER_FUNCTION_CALL],
        [Blockly.Solidity.ORDER_LOGICAL_NOT, Blockly.Solidity.ORDER_LOGICAL_NOT],
        [Blockly.Solidity.ORDER_MULTIPLICATION, Blockly.Solidity.ORDER_MULTIPLICATION],
        [Blockly.Solidity.ORDER_ADDITION,
            Blockly.Solidity.ORDER_ADDITION],
        [Blockly.Solidity.ORDER_LOGICAL_AND, Blockly.Solidity.ORDER_LOGICAL_AND],
        [Blockly.Solidity.ORDER_LOGICAL_OR, Blockly.Solidity.ORDER_LOGICAL_OR]
    ];

    Blockly.Solidity.isInitialized = !1;
    Blockly.Solidity.init = function (a) {
        Object.getPrototypeOf(this).init.call(this);
        this.nameDB_ ? this.nameDB_.reset() : this.nameDB_ = new Blockly.Names(this.RESERVED_WORDS_);
        this.nameDB_.setVariableMap(a.getVariableMap());
        this.nameDB_.populateVariables(a);
        this.nameDB_.populateProcedures(a);
        for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) b.push(this.nameDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
        a = Blockly.Variables.allUsedVarModels(a);
        for (d = 0; d < a.length; d++) b.push(this.nameDB_.getName(a[d].getId(),
            Blockly.VARIABLE_CATEGORY_NAME));
        b.length && (this.definitions_.variables = "var " + b.join(", ") + ";");
        this.isInitialized = !0
    };
    Blockly.Solidity.finish = function (a) {
        var b = Blockly.utils.object.values(this.definitions_);
        a = Object.getPrototypeOf(this).finish.call(this, a);
        this.isInitialized = !1;
        this.nameDB_.reset();
        return b.join("\n\n") + "\n\n\n" + a
    };
    Blockly.Solidity.scrubNakedValue = function (a) {
        return a + ";\n"
    };
    Blockly.Solidity.quote_ = function (a) {
        a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/'/g, "\\'");
        return "'" + a + "'"
    };
    Blockly.Solidity.multiline_quote_ = function (a) {
        return a.split(/\n/g).map(this.quote_).join(" + '\\n' +\n")
    };
    Blockly.Solidity.scrub_ = function (a, b, c) {
        var d = "";
        if (!a.outputConnection || !a.outputConnection.targetConnection) {
            var e = a.getCommentText();
            e && (e = Blockly.utils.string.wrap(e, this.COMMENT_WRAP - 3), d += this.prefixLines(e + "\n", "// "));
            for (var f = 0; f < a.inputList.length; f++) a.inputList[f].type == Blockly.inputTypes.VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = this.allNestedComments(e)) && (d += this.prefixLines(e, "// "))
        }
        a = a.nextConnection && a.nextConnection.targetBlock();
        c = c ? "" : this.blockToCode(a);
        return d +
            b + c
    };
    Blockly.Solidity.getAdjusted = function (a, b, c, d, e) {
        c = c || 0;
        e = e || this.ORDER_NONE;
        a.workspace.options.oneBasedIndex && c--;
        var f = a.workspace.options.oneBasedIndex ? "1" : "0";
        a = 0 < c ? this.valueToCode(a, b, this.ORDER_ADDITION) || f : 0 > c ? this.valueToCode(a, b, this.ORDER_SUBTRACTION) || f : d ? this.valueToCode(a, b, this.ORDER_UNARY_NEGATION) || f : this.valueToCode(a, b, e) || f;
        if (Blockly.isNumber(a)) a = Number(a) + c, d && (a = -a); else {
            if (0 < c) {
                a = a + " + " + c;
                var g = this.ORDER_ADDITION
            } else 0 > c && (a = a + " - " + -c, g = this.ORDER_SUBTRACTION);
            d && (a =
                c ? "-(" + a + ")" : "-" + a, g = this.ORDER_UNARY_NEGATION);
            g = Math.floor(g);
            e = Math.floor(e);
            g && e >= g && (a = "(" + a + ")")
        }
        return a
    };
    Blockly.Solidity.colour = {};
    Blockly.Solidity.colour_picker = function (a) {
        return [Blockly.Solidity.quote_(a.getFieldValue("COLOUR")), Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.colour_random = function (a) {
        return [Blockly.Solidity.provideFunction_("colourRandom", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "() {", "  var num = Math.floor(Math.random() * Math.pow(2, 24));", "  return '#' + ('00000' + num.toString(16)).substr(-6);", "}"]) + "()", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.colour_rgb = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "RED", Blockly.Solidity.ORDER_NONE) || 0,
            c = Blockly.Solidity.valueToCode(a, "GREEN", Blockly.Solidity.ORDER_NONE) || 0;
        a = Blockly.Solidity.valueToCode(a, "BLUE", Blockly.Solidity.ORDER_NONE) || 0;
        return [Blockly.Solidity.provideFunction_("colourRgb", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b) {", "  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;", "  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;",
            "  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;", "  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);", "  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);", "  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.colour_blend = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "COLOUR1", Blockly.Solidity.ORDER_NONE) || "'#000000'",
            c = Blockly.Solidity.valueToCode(a, "COLOUR2", Blockly.Solidity.ORDER_NONE) || "'#000000'";
        a = Blockly.Solidity.valueToCode(a, "RATIO", Blockly.Solidity.ORDER_NONE) || .5;
        return [Blockly.Solidity.provideFunction_("colourBlend", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(c1, c2, ratio) {", "  ratio = Math.max(Math.min(Number(ratio), 1), 0);", "  var r1 = parseInt(c1.substring(1, 3), 16);",
            "  var g1 = parseInt(c1.substring(3, 5), 16);", "  var b1 = parseInt(c1.substring(5, 7), 16);", "  var r2 = parseInt(c2.substring(1, 3), 16);", "  var g2 = parseInt(c2.substring(3, 5), 16);", "  var b2 = parseInt(c2.substring(5, 7), 16);", "  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);", "  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);", "  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);", "  r = ('0' + (r || 0).toString(16)).slice(-2);", "  g = ('0' + (g || 0).toString(16)).slice(-2);", "  b = ('0' + (b || 0).toString(16)).slice(-2);",
            "  return '#' + r + g + b;", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists = {};
    Blockly.Solidity.lists_create_empty = function (a) {
        return ["[]", Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.lists_create_with = function (a) {
        for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.Solidity.valueToCode(a, "ADD" + c, Blockly.Solidity.ORDER_NONE) || "null";
        return ["[" + b.join(", ") + "]", Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.lists_repeat = function (a) {
        var b = Blockly.Solidity.provideFunction_("listsRepeat", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(value, n) {", "  var array = [];", "  for (var i = 0; i < n; i++) {", "    array[i] = value;", "  }", "  return array;", "}"]),
            c = Blockly.Solidity.valueToCode(a, "ITEM", Blockly.Solidity.ORDER_NONE) || "null";
        a = Blockly.Solidity.valueToCode(a, "NUM", Blockly.Solidity.ORDER_NONE) || "0";
        return [b + "(" + c + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists_length = function (a) {
        return [(Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "[]") + ".length", Blockly.Solidity.ORDER_MEMBER]
    };
    Blockly.Solidity.lists_isEmpty = function (a) {
        return ["!" + (Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "[]") + ".length", Blockly.Solidity.ORDER_LOGICAL_NOT]
    };
    Blockly.Solidity.lists_indexOf = function (a) {
        var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
            c = Blockly.Solidity.valueToCode(a, "FIND", Blockly.Solidity.ORDER_NONE) || "''";
        b = (Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "[]") + "." + b + "(" + c + ")";
        return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.Solidity.ORDER_ADDITION] : [b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists_getIndex = function (a) {
        var b = a.getFieldValue("MODE") || "GET", c = a.getFieldValue("WHERE") || "FROM_START",
            d = Blockly.Solidity.valueToCode(a, "VALUE", "RANDOM" == c ? Blockly.Solidity.ORDER_NONE : Blockly.Solidity.ORDER_MEMBER) || "[]";
        switch (c) {
            case "FIRST":
                if ("GET" == b) return [d + "[0]", Blockly.Solidity.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".shift()", Blockly.Solidity.ORDER_MEMBER];
                if ("REMOVE" == b) return d + ".shift();\n";
                break;
            case "LAST":
                if ("GET" == b) return [d + ".slice(-1)[0]", Blockly.Solidity.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop()", Blockly.Solidity.ORDER_MEMBER];
                if ("REMOVE" == b) return d + ".pop();\n";
                break;
            case "FROM_START":
                a = Blockly.Solidity.getAdjusted(a, "AT");
                if ("GET" == b) return [d + "[" + a + "]", Blockly.Solidity.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.Solidity.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".splice(" + a + ", 1);\n";
                break;
            case "FROM_END":
                a = Blockly.Solidity.getAdjusted(a, "AT", 1, !0);
                if ("GET" == b) return [d + ".slice(" + a + ")[0]", Blockly.Solidity.ORDER_FUNCTION_CALL];
                if ("GET_REMOVE" == b) return [d + ".splice(" + a + ", 1)[0]", Blockly.Solidity.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".splice(" + a + ", 1);";
                break;
            case "RANDOM":
                d = Blockly.Solidity.provideFunction_("listsGetRandomItem", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(list, remove) {", "  var x = Math.floor(Math.random() * list.length);", "  if (remove) {", "    return list.splice(x, 1)[0];", "  } else {", "    return list[x];", "  }", "}"]) + "(" + d + ", " + ("GET" != b) + ")";
                if ("GET" == b || "GET_REMOVE" == b) return [d,
                    Blockly.Solidity.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ";\n"
        }
        throw Error("Unhandled combination (lists_getIndex).");
    };
    Blockly.Solidity.lists_setIndex = function (a) {
        function b() {
            if (c.match(/^\w+$/)) return "";
            var g = Blockly.Solidity.nameDB_.getDistinctName("tmpList", Blockly.VARIABLE_CATEGORY_NAME),
                h = "var " + g + " = " + c + ";\n";
            c = g;
            return h
        }

        var c = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_MEMBER) || "[]",
            d = a.getFieldValue("MODE") || "GET", e = a.getFieldValue("WHERE") || "FROM_START",
            f = Blockly.Solidity.valueToCode(a, "TO", Blockly.Solidity.ORDER_ASSIGNMENT) || "null";
        switch (e) {
            case "FIRST":
                if ("SET" == d) return c +
                    "[0] = " + f + ";\n";
                if ("INSERT" == d) return c + ".unshift(" + f + ");\n";
                break;
            case "LAST":
                if ("SET" == d) return a = b(), a + (c + "[" + c + ".length - 1] = " + f + ";\n");
                if ("INSERT" == d) return c + ".push(" + f + ");\n";
                break;
            case "FROM_START":
                e = Blockly.Solidity.getAdjusted(a, "AT");
                if ("SET" == d) return c + "[" + e + "] = " + f + ";\n";
                if ("INSERT" == d) return c + ".splice(" + e + ", 0, " + f + ");\n";
                break;
            case "FROM_END":
                e = Blockly.Solidity.getAdjusted(a, "AT", 1, !1, Blockly.Solidity.ORDER_SUBTRACTION);
                a = b();
                if ("SET" == d) return a + (c + "[" + c + ".length - " + e +
                    "] = " + f + ";\n");
                if ("INSERT" == d) return a + (c + ".splice(" + c + ".length - " + e + ", 0, " + f + ");\n");
                break;
            case "RANDOM":
                a = b();
                e = Blockly.Solidity.nameDB_.getDistinctName("tmpX", Blockly.VARIABLE_CATEGORY_NAME);
                a += "var " + e + " = Math.floor(Math.random() * " + c + ".length);\n";
                if ("SET" == d) return a + (c + "[" + e + "] = " + f + ";\n");
                if ("INSERT" == d) return a + (c + ".splice(" + e + ", 0, " + f + ");\n")
        }
        throw Error("Unhandled combination (lists_setIndex).");
    };
    Blockly.Solidity.lists.getIndex_ = function (a, b, c) {
        return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c
    };
    Blockly.Solidity.lists_getSublist = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_MEMBER) || "[]",
            c = a.getFieldValue("WHERE1"), d = a.getFieldValue("WHERE2");
        if ("FIRST" == c && "LAST" == d) b += ".slice(0)"; else if (b.match(/^\w+$/) || "FROM_END" != c && "FROM_START" == d) {
            switch (c) {
                case "FROM_START":
                    var e = Blockly.Solidity.getAdjusted(a, "AT1");
                    break;
                case "FROM_END":
                    e = Blockly.Solidity.getAdjusted(a, "AT1", 1, !1, Blockly.Solidity.ORDER_SUBTRACTION);
                    e = b + ".length - " + e;
                    break;
                case "FIRST":
                    e =
                        "0";
                    break;
                default:
                    throw Error("Unhandled option (lists_getSublist).");
            }
            switch (d) {
                case "FROM_START":
                    a = Blockly.Solidity.getAdjusted(a, "AT2", 1);
                    break;
                case "FROM_END":
                    a = Blockly.Solidity.getAdjusted(a, "AT2", 0, !1, Blockly.Solidity.ORDER_SUBTRACTION);
                    a = b + ".length - " + a;
                    break;
                case "LAST":
                    a = b + ".length";
                    break;
                default:
                    throw Error("Unhandled option (lists_getSublist).");
            }
            b = b + ".slice(" + e + ", " + a + ")"
        } else {
            e = Blockly.Solidity.getAdjusted(a, "AT1");
            a = Blockly.Solidity.getAdjusted(a, "AT2");
            var f = Blockly.Solidity.lists.getIndex_,
                g = {FIRST: "First", LAST: "Last", FROM_START: "FromStart", FROM_END: "FromEnd"};
            b = Blockly.Solidity.provideFunction_("subsequence" + g[c] + g[d], ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == c || "FROM_START" == c ? ", at1" : "") + ("FROM_END" == d || "FROM_START" == d ? ", at2" : "") + ") {", "  var start = " + f("sequence", c, "at1") + ";", "  var end = " + f("sequence", d, "at2") + " + 1;", "  return sequence.slice(start, end);", "}"]) + "(" + b + ("FROM_END" == c || "FROM_START" == c ? ", " + e : "") + ("FROM_END" == d || "FROM_START" ==
            d ? ", " + a : "") + ")"
        }
        return [b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists_sort = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_FUNCTION_CALL) || "[]",
            c = "1" === a.getFieldValue("DIRECTION") ? 1 : -1;
        a = a.getFieldValue("TYPE");
        var d = Blockly.Solidity.provideFunction_("listsGetSortCompare", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(type, direction) {", "  var compareFuncs = {", '    "NUMERIC": function(a, b) {', "        return Number(a) - Number(b); },", '    "TEXT": function(a, b) {', "        return a.toString() > b.toString() ? 1 : -1; },",
            '    "IGNORE_CASE": function(a, b) {', "        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },", "  };", "  var compare = compareFuncs[type];", "  return function(a, b) { return compare(a, b) * direction; }", "}"]);
        return [b + ".slice().sort(" + d + '("' + a + '", ' + c + "))", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists_split = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "INPUT", Blockly.Solidity.ORDER_MEMBER),
            c = Blockly.Solidity.valueToCode(a, "DELIM", Blockly.Solidity.ORDER_NONE) || "''";
        a = a.getFieldValue("MODE");
        if ("SPLIT" == a) b || (b = "''"), a = "split"; else if ("JOIN" == a) b || (b = "[]"), a = "join"; else throw Error("Unknown mode: " + a);
        return [b + "." + a + "(" + c + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.lists_reverse = function (a) {
        return [(Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_FUNCTION_CALL) || "[]") + ".slice().reverse()", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.logic = {};
    Blockly.Solidity.controls_if = function (a) {
        var b = 0, c = "";
        Blockly.Solidity.STATEMENT_PREFIX && (c += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_PREFIX, a));
        do {
            var d = Blockly.Solidity.valueToCode(a, "IF" + b, Blockly.Solidity.ORDER_NONE) || "false";
            var e = Blockly.Solidity.statementToCode(a, "DO" + b);
            Blockly.Solidity.STATEMENT_SUFFIX && (e = Blockly.Solidity.prefixLines(Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_SUFFIX, a), Blockly.Solidity.INDENT) + e);
            c += (0 < b ? " else " : "") + "if (" +
                d + ") {\n" + e + "}";
            ++b
        } while (a.getInput("IF" + b));
        if (a.getInput("ELSE") || Blockly.Solidity.STATEMENT_SUFFIX) e = Blockly.Solidity.statementToCode(a, "ELSE"), Blockly.Solidity.STATEMENT_SUFFIX && (e = Blockly.Solidity.prefixLines(Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_SUFFIX, a), Blockly.Solidity.INDENT) + e), c += " else {\n" + e + "}";
        return c + "\n"
    };
    Blockly.Solidity.controls_ifelse = Blockly.Solidity.controls_if;
    Blockly.Solidity.logic_compare = function (a) {
        var b = {EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">="}[a.getFieldValue("OP")],
            c = "==" == b || "!=" == b ? Blockly.Solidity.ORDER_EQUALITY : Blockly.Solidity.ORDER_RELATIONAL,
            d = Blockly.Solidity.valueToCode(a, "A", c) || "0";
        a = Blockly.Solidity.valueToCode(a, "B", c) || "0";
        return [d + " " + b + " " + a, c]
    };
    Blockly.Solidity.logic_operation = function (a) {
        var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
            c = "&&" == b ? Blockly.Solidity.ORDER_LOGICAL_AND : Blockly.Solidity.ORDER_LOGICAL_OR,
            d = Blockly.Solidity.valueToCode(a, "A", c);
        a = Blockly.Solidity.valueToCode(a, "B", c);
        if (d || a) {
            var e = "&&" == b ? "true" : "false";
            d || (d = e);
            a || (a = e)
        } else a = d = "false";
        return [d + " " + b + " " + a, c]
    };
    Blockly.Solidity.logic_negate = function (a) {
        var b = Blockly.Solidity.ORDER_LOGICAL_NOT;
        return ["!" + (Blockly.Solidity.valueToCode(a, "BOOL", b) || "true"), b]
    };
    Blockly.Solidity.logic_boolean = function (a) {
        return ["TRUE" == a.getFieldValue("BOOL") ? "true" : "false", Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.logic_null = function (a) {
        return ["null", Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.logic_ternary = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "IF", Blockly.Solidity.ORDER_CONDITIONAL) || "false",
            c = Blockly.Solidity.valueToCode(a, "THEN", Blockly.Solidity.ORDER_CONDITIONAL) || "null";
        a = Blockly.Solidity.valueToCode(a, "ELSE", Blockly.Solidity.ORDER_CONDITIONAL) || "null";
        return [b + " ? " + c + " : " + a, Blockly.Solidity.ORDER_CONDITIONAL]
    };
    Blockly.Solidity.loops = {};
    Blockly.Solidity.controls_repeat_ext = function (a) {
        var b = a.getField("TIMES") ? String(Number(a.getFieldValue("TIMES"))) : Blockly.Solidity.valueToCode(a, "TIMES", Blockly.Solidity.ORDER_ASSIGNMENT) || "0",
            c = Blockly.Solidity.statementToCode(a, "DO");
        c = Blockly.Solidity.addLoopTrap(c, a);
        a = "";
        var d = Blockly.Solidity.nameDB_.getDistinctName("count", Blockly.VARIABLE_CATEGORY_NAME), e = b;
        b.match(/^\w+$/) || Blockly.isNumber(b) || (e = Blockly.Solidity.nameDB_.getDistinctName("repeat_end", Blockly.VARIABLE_CATEGORY_NAME),
            a += "uint256 " + e + " = " + b + ";\n");
        return a + ("for (uint256 " + d + " = 0; " + d + " < " + e + "; " + d + "++) {\n" + c + "}\n")
    };
    Blockly.Solidity.controls_repeat = Blockly.Solidity.controls_repeat_ext;
    Blockly.Solidity.controls_whileUntil = function (a) {
        var b = "UNTIL" == a.getFieldValue("MODE"),
            c = Blockly.Solidity.valueToCode(a, "BOOL", b ? Blockly.Solidity.ORDER_LOGICAL_NOT : Blockly.Solidity.ORDER_NONE) || "false",
            d = Blockly.Solidity.statementToCode(a, "DO");
        d = Blockly.Solidity.addLoopTrap(d, a);
        b && (c = "!" + c);
        return "while (" + c + ") {\n" + d + "}\n"
    };
    Blockly.Solidity.controls_for = function (block) {
        // For loop.
        var variable0 = Blockly.Solidity.nameDB_.getName(
            block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
        var argument0 = Blockly.Solidity.valueToCode(block, 'FROM',
            Blockly.Solidity.ORDER_ASSIGNMENT) || '0';
        var argument1 = Blockly.Solidity.valueToCode(block, 'TO',
            Blockly.Solidity.ORDER_ASSIGNMENT) || '0';
        var increment = Blockly.Solidity.valueToCode(block, 'BY',
            Blockly.Solidity.ORDER_ASSIGNMENT) || '1';
        var branch = Blockly.Solidity.statementToCode(block, 'DO');
        branch = Blockly.Solidity.addLoopTrap(branch, block);
        var code;
        if (Blockly.isNumber(argument0) && Blockly.isNumber(argument1) &&
            Blockly.isNumber(increment)) {
            // All arguments are simple numbers.
            var up = Number(argument0) <= Number(argument1);
            code = 'for (' + variable0 + ' = ' + argument0 + '; ' +
                variable0 + (up ? ' <= ' : ' >= ') + argument1 + '; ' +
                variable0;
            var step = Math.abs(Number(increment));
            if (step == 1) {
                code += up ? '++' : '--';
            } else {
                code += (up ? ' += ' : ' -= ') + step;
            }
            code += ') {\n' + branch + '}\n';
        } else {
            code = '';
            // Cache non-trivial values to variables to prevent repeated look-ups.
            var startVar = argument0;
            if (!argument0.match(/^\w+$/) && !Blockly.isNumber(argument0)) {
                startVar = Blockly.Solidity.nameDB_.getDistinctName(
                    variable0 + '_start', Blockly.VARIABLE_CATEGORY_NAME);
                code += 'uint256 ' + startVar + ' = ' + argument0 + ';\n';
            }
            var endVar = argument1;
            if (!argument1.match(/^\w+$/) && !Blockly.isNumber(argument1)) {
                endVar = Blockly.Solidity.nameDB_.getDistinctName(
                    variable0 + '_end', Blockly.VARIABLE_CATEGORY_NAME);
                code += 'uint256 ' + endVar + ' = ' + argument1 + ';\n';
            }
            // Determine loop direction at start, in case one of the bounds
            // changes during loop execution.
            var incVar = Blockly.Solidity.nameDB_.getDistinctName(
                variable0 + '_inc', Blockly.VARIABLE_CATEGORY_NAME);
            code += 'uint256 ' + incVar + ' = ';
            if (Blockly.isNumber(increment)) {
                code += Math.abs(increment) + ';\n';
            } else {
                code += 'Math.abs(' + increment + ');\n';
            }
            code += 'if (' + startVar + ' > ' + endVar + ') {\n';
            code += Blockly.Solidity.INDENT + incVar + ' = -' + incVar + ';\n';
            code += '}\n';
            code += 'for (' + variable0 + ' = ' + startVar + '; ' +
                incVar + ' >= 0 ? ' +
                variable0 + ' <= ' + endVar + ' : ' +
                variable0 + ' >= ' + endVar + '; ' +
                variable0 + ' += ' + incVar + ') {\n' +
                branch + '}\n';
        }
        return code;
    };
    Blockly.Solidity.controls_forEach = function (a) {
        var b = Blockly.Solidity.nameDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
            c = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_ASSIGNMENT) || "[]",
            d = Blockly.Solidity.statementToCode(a, "DO");
        d = Blockly.Solidity.addLoopTrap(d, a);
        a = "";
        var e = c;
        c.match(/^\w+$/) || (e = Blockly.Solidity.nameDB_.getDistinctName(b + "_list", Blockly.VARIABLE_CATEGORY_NAME), a += "var " + e + " = " + c + ";\n");
        c = Blockly.Solidity.nameDB_.getDistinctName(b +
            "_index", Blockly.VARIABLE_CATEGORY_NAME);
        d = Blockly.Solidity.INDENT + b + " = " + e + "[" + c + "];\n" + d;
        return a + ("for (var " + c + " in " + e + ") {\n" + d + "}\n")
    };
    Blockly.Solidity.controls_flow_statements = function (a) {
        var b = "";
        Blockly.Solidity.STATEMENT_PREFIX && (b += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_PREFIX, a));
        Blockly.Solidity.STATEMENT_SUFFIX && (b += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_SUFFIX, a));
        if (Blockly.Solidity.STATEMENT_PREFIX) {
            var c = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);
            c && !c.suppressPrefixSuffix && (b += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_PREFIX,
                c))
        }
        switch (a.getFieldValue("FLOW")) {
            case "BREAK":
                return b + "break;\n";
            case "CONTINUE":
                return b + "continue;\n"
        }
        throw Error("Unknown flow statement.");
    };
    Blockly.Solidity.math = {};
    Blockly.Solidity.math_number = function (a) {
        a = Number(a.getFieldValue("NUM"));
        return [a, 0 <= a ? Blockly.Solidity.ORDER_ATOMIC : Blockly.Solidity.ORDER_UNARY_NEGATION]
    };
    Blockly.Solidity.math_arithmetic = function (block) {
        var OPERATORS = {
            'ADD': [' + ', Blockly.Solidity.ORDER_ADDITION],
            'MINUS': [' - ', Blockly.Solidity.ORDER_SUBTRACTION],
            'MULTIPLY': [' * ', Blockly.Solidity.ORDER_MULTIPLICATION],
            'DIVIDE': [' / ', Blockly.Solidity.ORDER_DIVISION],
            'POWER': [null, Blockly.Solidity.ORDER_COMMA]  // Handle power separately.
        };
        var tuple = OPERATORS[block.getFieldValue('OP')];
        var operator = tuple[0];
        var order = tuple[1];
        var argument0 = Blockly.Solidity.valueToCode(block, 'A', order) || '0';
        var argument1 = Blockly.Solidity.valueToCode(block, 'B', order) || '0';
        var code;
        // Power in Solidity requires a special case since it has no operator.
        if (!operator) {
            code = 'Math.pow(' + argument0 + ', ' + argument1 + ')';
            return [code, Blockly.Solidity.ORDER_FUNCTION_CALL];
        }
        code = argument0 + operator + argument1;
        return [code, order];
    };
    Blockly.Solidity.math_single = function (a) {
        var b = a.getFieldValue("OP");
        if ("NEG" == b) return a = Blockly.Solidity.valueToCode(a, "NUM", Blockly.Solidity.ORDER_UNARY_NEGATION) || "0", "-" == a[0] && (a = " " + a), ["-" + a, Blockly.Solidity.ORDER_UNARY_NEGATION];
        a = "SIN" == b || "COS" == b || "TAN" == b ? Blockly.Solidity.valueToCode(a, "NUM", Blockly.Solidity.ORDER_DIVISION) || "0" : Blockly.Solidity.valueToCode(a, "NUM", Blockly.Solidity.ORDER_NONE) || "0";
        switch (b) {
            case "ABS":
                var c = "Math.abs(" + a + ")";
                break;
            case "ROOT":
                c = "Math.sqrt(" +
                    a + ")";
                break;
            case "LN":
                c = "Math.log(" + a + ")";
                break;
            case "EXP":
                c = "Math.exp(" + a + ")";
                break;
            case "POW10":
                c = "Math.pow(10," + a + ")";
                break;
            case "ROUND":
                c = "Math.round(" + a + ")";
                break;
            case "ROUNDUP":
                c = "Math.ceil(" + a + ")";
                break;
            case "ROUNDDOWN":
                c = "Math.floor(" + a + ")";
                break;
            case "SIN":
                c = "Math.sin(" + a + " / 180 * Math.PI)";
                break;
            case "COS":
                c = "Math.cos(" + a + " / 180 * Math.PI)";
                break;
            case "TAN":
                c = "Math.tan(" + a + " / 180 * Math.PI)"
        }
        if (c) return [c, Blockly.Solidity.ORDER_FUNCTION_CALL];
        switch (b) {
            case "LOG10":
                c = "Math.log(" + a +
                    ") / Math.log(10)";
                break;
            case "ASIN":
                c = "Math.asin(" + a + ") / Math.PI * 180";
                break;
            case "ACOS":
                c = "Math.acos(" + a + ") / Math.PI * 180";
                break;
            case "ATAN":
                c = "Math.atan(" + a + ") / Math.PI * 180";
                break;
            default:
                throw Error("Unknown math operator: " + b);
        }
        return [c, Blockly.Solidity.ORDER_DIVISION]
    };
    Blockly.Solidity.math_constant = function (a) {
        return {
            PI: ["Math.PI", Blockly.Solidity.ORDER_MEMBER],
            E: ["Math.E", Blockly.Solidity.ORDER_MEMBER],
            GOLDEN_RATIO: ["(1 + Math.sqrt(5)) / 2", Blockly.Solidity.ORDER_DIVISION],
            SQRT2: ["Math.SQRT2", Blockly.Solidity.ORDER_MEMBER],
            SQRT1_2: ["Math.SQRT1_2", Blockly.Solidity.ORDER_MEMBER],
            INFINITY: ["Infinity", Blockly.Solidity.ORDER_ATOMIC]
        }[a.getFieldValue("CONSTANT")]
    };
    Blockly.Solidity.math_number_property = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "NUMBER_TO_CHECK", Blockly.Solidity.ORDER_MODULUS) || "0",
            c = a.getFieldValue("PROPERTY");
        if ("PRIME" == c) return [Blockly.Solidity.provideFunction_("mathIsPrime", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(n) {", "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods", "  if (n == 2 || n == 3) {", "    return true;", "  }", "  // False if n is NaN, negative, is 1, or not whole.", "  // And false if n is divisible by 2 or 3.",
            "  if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {", "    return false;", "  }", "  // Check all the numbers of form 6k +/- 1, up to sqrt(n).", "  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {", "    if (n % (x - 1) == 0 || n % (x + 1) == 0) {", "      return false;", "    }", "  }", "  return true;", "}"]) + "(" + b + ")", Blockly.Solidity.ORDER_FUNCTION_CALL];
        switch (c) {
            case "EVEN":
                var d = b + " % 2 == 0";
                break;
            case "ODD":
                d = b + " % 2 == 1";
                break;
            case "WHOLE":
                d = b + " % 1 == 0";
                break;
            case "POSITIVE":
                d =
                    b + " > 0";
                break;
            case "NEGATIVE":
                d = b + " < 0";
                break;
            case "DIVISIBLE_BY":
                a = Blockly.Solidity.valueToCode(a, "DIVISOR", Blockly.Solidity.ORDER_MODULUS) || "0", d = b + " % " + a + " == 0"
        }
        return [d, Blockly.Solidity.ORDER_EQUALITY]
    };
    Blockly.Solidity.math_change = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "DELTA", Blockly.Solidity.ORDER_ADDITION) || "0";
        a = Blockly.Solidity.nameDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        return a + " = (typeof " + a + " == 'number' ? " + a + " : 0) + " + b + ";\n"
    };
    Blockly.Solidity.math_round = Blockly.Solidity.math_single;
    Blockly.Solidity.math_trig = Blockly.Solidity.math_single;
    Blockly.Solidity.math_on_list = function (a) {
        var b = a.getFieldValue("OP");
        switch (b) {
            case "SUM":
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_MEMBER) || "[]";
                a += ".reduce(function(x, y) {return x + y;})";
                break;
            case "MIN":
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = "Math.min.apply(null, " + a + ")";
                break;
            case "MAX":
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = "Math.max.apply(null, " + a + ")";
                break;
            case "AVERAGE":
                b = Blockly.Solidity.provideFunction_("mathMean",
                    ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  return myList.reduce(function(x, y) {return x + y;}) / myList.length;", "}"]);
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = b + "(" + a + ")";
                break;
            case "MEDIAN":
                b = Blockly.Solidity.provideFunction_("mathMedian", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {", "  var localList = myList.filter(function (x) {return typeof x == 'number';});", "  if (!localList.length) return null;",
                    "  localList.sort(function(a, b) {return b - a;});", "  if (localList.length % 2 == 0) {", "    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;", "  } else {", "    return localList[(localList.length - 1) / 2];", "  }", "}"]);
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = b + "(" + a + ")";
                break;
            case "MODE":
                b = Blockly.Solidity.provideFunction_("mathModes", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(values) {", "  var modes = [];",
                    "  var counts = [];", "  var maxCount = 0;", "  for (var i = 0; i < values.length; i++) {", "    var value = values[i];", "    var found = false;", "    var thisCount;", "    for (var j = 0; j < counts.length; j++) {", "      if (counts[j][0] === value) {", "        thisCount = ++counts[j][1];", "        found = true;", "        break;", "      }", "    }", "    if (!found) {", "      counts.push([value, 1]);", "      thisCount = 1;", "    }", "    maxCount = Math.max(thisCount, maxCount);", "  }", "  for (var j = 0; j < counts.length; j++) {",
                    "    if (counts[j][1] == maxCount) {", "        modes.push(counts[j][0]);", "    }", "  }", "  return modes;", "}"]);
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = b + "(" + a + ")";
                break;
            case "STD_DEV":
                b = Blockly.Solidity.provideFunction_("mathStandardDeviation", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(numbers) {", "  var n = numbers.length;", "  if (!n) return null;", "  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;", "  var variance = 0;",
                    "  for (var j = 0; j < n; j++) {", "    variance += Math.pow(numbers[j] - mean, 2);", "  }", "  variance = variance / n;", "  return Math.sqrt(variance);", "}"]);
                a = Blockly.Solidity.valueToCode(a, "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = b + "(" + a + ")";
                break;
            case "RANDOM":
                b = Blockly.Solidity.provideFunction_("mathRandomList", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(list) {", "  var x = Math.floor(Math.random() * list.length);", "  return list[x];", "}"]);
                a = Blockly.Solidity.valueToCode(a,
                    "LIST", Blockly.Solidity.ORDER_NONE) || "[]";
                a = b + "(" + a + ")";
                break;
            default:
                throw Error("Unknown operator: " + b);
        }
        return [a, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.math_modulo = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "DIVIDEND", Blockly.Solidity.ORDER_MODULUS) || "0";
        a = Blockly.Solidity.valueToCode(a, "DIVISOR", Blockly.Solidity.ORDER_MODULUS) || "0";
        return [b + " % " + a, Blockly.Solidity.ORDER_MODULUS]
    };
    Blockly.Solidity.math_constrain = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_NONE) || "0",
            c = Blockly.Solidity.valueToCode(a, "LOW", Blockly.Solidity.ORDER_NONE) || "0";
        a = Blockly.Solidity.valueToCode(a, "HIGH", Blockly.Solidity.ORDER_NONE) || "Infinity";
        return ["Math.min(Math.max(" + b + ", " + c + "), " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.math_random_int = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "FROM", Blockly.Solidity.ORDER_NONE) || "0";
        a = Blockly.Solidity.valueToCode(a, "TO", Blockly.Solidity.ORDER_NONE) || "0";
        return [Blockly.Solidity.provideFunction_("mathRandomInt", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(a, b) {", "  if (a > b) {", "    // Swap a and b to ensure a is smaller.", "    var c = a;", "    a = b;", "    b = c;", "  }", "  return Math.floor(Math.random() * (b - a + 1) + a);",
            "}"]) + "(" + b + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.math_random_float = function (a) {
        return ["Math.random()", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.math_atan2 = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "X", Blockly.Solidity.ORDER_NONE) || "0";
        return ["Math.atan2(" + (Blockly.Solidity.valueToCode(a, "Y", Blockly.Solidity.ORDER_NONE) || "0") + ", " + b + ") / Math.PI * 180", Blockly.Solidity.ORDER_DIVISION]
    };
    Blockly.Solidity.procedures = {};
    Blockly.Solidity.procedures_defreturn = function (a) {
        var b = Blockly.Solidity.nameDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = "";
        Blockly.Solidity.STATEMENT_PREFIX && (c += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_PREFIX, a));
        Blockly.Solidity.STATEMENT_SUFFIX && (c += Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_SUFFIX, a));
        c && (c = Blockly.Solidity.prefixLines(c, Blockly.Solidity.INDENT));
        var d = "";
        Blockly.Solidity.INFINITE_LOOP_TRAP && (d = Blockly.Solidity.prefixLines(Blockly.Solidity.injectId(Blockly.Solidity.INFINITE_LOOP_TRAP,
            a), Blockly.Solidity.INDENT));
        var e = Blockly.Solidity.statementToCode(a, "STACK"),
            f = Blockly.Solidity.valueToCode(a, "RETURN", Blockly.Solidity.ORDER_NONE) || "", g = "";
        e && f && (g = c);
        f && (f = Blockly.Solidity.INDENT + "return " + f + ";\n");
        for (var h = [], l = a.getVars(), k = 0; k < l.length; k++) h[k] = Blockly.Solidity.nameDB_.getName(l[k], Blockly.VARIABLE_CATEGORY_NAME);
        c = "function " + b + "(" + h.join(", ") + ") {\n" + c + d + e + g + f + "}";
        c = Blockly.Solidity.scrub_(a, c);
        Blockly.Solidity.definitions_["%" + b] = c;
        return null
    };
    Blockly.Solidity.procedures_defnoreturn = Blockly.Solidity.procedures_defreturn;
    Blockly.Solidity.procedures_callreturn = function (a) {
        for (var b = Blockly.Solidity.nameDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = [], d = a.getVars(), e = 0; e < d.length; e++) c[e] = Blockly.Solidity.valueToCode(a, "ARG" + e, Blockly.Solidity.ORDER_NONE) || "null";
        return [b + "(" + c.join(", ") + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.procedures_callnoreturn = function (a) {
        return Blockly.Solidity.procedures_callreturn(a)[0] + ";\n"
    };
    Blockly.Solidity.procedures_ifreturn = function (a) {
        var b = "if (" + (Blockly.Solidity.valueToCode(a, "CONDITION", Blockly.Solidity.ORDER_NONE) || "false") + ") {\n";
        Blockly.Solidity.STATEMENT_SUFFIX && (b += Blockly.Solidity.prefixLines(Blockly.Solidity.injectId(Blockly.Solidity.STATEMENT_SUFFIX, a), Blockly.Solidity.INDENT));
        a.hasReturnValue_ ? (a = Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_NONE) || "null", b += Blockly.Solidity.INDENT + "return " + a + ";\n") : b += Blockly.Solidity.INDENT +
            "return;\n";
        return b + "}\n"
    };
    Blockly.Solidity.texts = {};
    Blockly.Solidity.text = function (a) {
        return [Blockly.Solidity.quote_(a.getFieldValue("TEXT")), Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.text_multiline = function (a) {
        a = Blockly.Solidity.multiline_quote_(a.getFieldValue("TEXT"));
        var b = -1 != a.indexOf("+") ? Blockly.Solidity.ORDER_ADDITION : Blockly.Solidity.ORDER_ATOMIC;
        return [a, b]
    };
    Blockly.Solidity.text.forceString_ = function (a) {
        return Blockly.Solidity.text.forceString_.strRegExp.test(a) ? [a, Blockly.Solidity.ORDER_ATOMIC] : ["String(" + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text.forceString_.strRegExp = /^\s*'([^']|\\')*'\s*$/;
    Blockly.Solidity.text_join = function (a) {
        switch (a.itemCount_) {
            case 0:
                return ["''", Blockly.Solidity.ORDER_ATOMIC];
            case 1:
                return a = Blockly.Solidity.valueToCode(a, "ADD0", Blockly.Solidity.ORDER_NONE) || "''", Blockly.Solidity.text.forceString_(a);
            case 2:
                var b = Blockly.Solidity.valueToCode(a, "ADD0", Blockly.Solidity.ORDER_NONE) || "''";
                a = Blockly.Solidity.valueToCode(a, "ADD1", Blockly.Solidity.ORDER_NONE) || "''";
                a = Blockly.Solidity.text.forceString_(b)[0] + " + " + Blockly.Solidity.text.forceString_(a)[0];
                return [a, Blockly.Solidity.ORDER_ADDITION];
            default:
                b = Array(a.itemCount_);
                for (var c = 0; c < a.itemCount_; c++) b[c] = Blockly.Solidity.valueToCode(a, "ADD" + c, Blockly.Solidity.ORDER_NONE) || "''";
                a = "[" + b.join(",") + "].join('')";
                return [a, Blockly.Solidity.ORDER_FUNCTION_CALL]
        }
    };
    Blockly.Solidity.text_append = function (a) {
        var b = Blockly.Solidity.nameDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        a = Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_NONE) || "''";
        return b + " += " + Blockly.Solidity.text.forceString_(a)[0] + ";\n"
    };
    Blockly.Solidity.text_length = function (a) {
        return [(Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "''") + ".length", Blockly.Solidity.ORDER_MEMBER]
    };
    Blockly.Solidity.text_isEmpty = function (a) {
        return ["!" + (Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "''") + ".length", Blockly.Solidity.ORDER_LOGICAL_NOT]
    };
    Blockly.Solidity.text_indexOf = function (a) {
        var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
            c = Blockly.Solidity.valueToCode(a, "FIND", Blockly.Solidity.ORDER_NONE) || "''";
        b = (Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_MEMBER) || "''") + "." + b + "(" + c + ")";
        return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.Solidity.ORDER_ADDITION] : [b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_charAt = function (a) {
        var b = a.getFieldValue("WHERE") || "FROM_START",
            c = Blockly.Solidity.valueToCode(a, "VALUE", "RANDOM" == b ? Blockly.Solidity.ORDER_NONE : Blockly.Solidity.ORDER_MEMBER) || "''";
        switch (b) {
            case "FIRST":
                return [c + ".charAt(0)", Blockly.Solidity.ORDER_FUNCTION_CALL];
            case "LAST":
                return [c + ".slice(-1)", Blockly.Solidity.ORDER_FUNCTION_CALL];
            case "FROM_START":
                return a = Blockly.Solidity.getAdjusted(a, "AT"), [c + ".charAt(" + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL];
            case "FROM_END":
                return a =
                    Blockly.Solidity.getAdjusted(a, "AT", 1, !0), [c + ".slice(" + a + ").charAt(0)", Blockly.Solidity.ORDER_FUNCTION_CALL];
            case "RANDOM":
                return [Blockly.Solidity.provideFunction_("textRandomLetter", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(text) {", "  var x = Math.floor(Math.random() * text.length);", "  return text[x];", "}"]) + "(" + c + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
        }
        throw Error("Unhandled option (text_charAt).");
    };
    Blockly.Solidity.text.getIndex_ = function (a, b, c) {
        return "FIRST" == b ? "0" : "FROM_END" == b ? a + ".length - 1 - " + c : "LAST" == b ? a + ".length - 1" : c
    };
    Blockly.Solidity.text_getSubstring = function (a) {
        var b = a.getFieldValue("WHERE1"), c = a.getFieldValue("WHERE2"),
            d = "FROM_END" != b && "LAST" != b && "FROM_END" != c && "LAST" != c,
            e = Blockly.Solidity.valueToCode(a, "STRING", d ? Blockly.Solidity.ORDER_MEMBER : Blockly.Solidity.ORDER_NONE) || "''";
        if ("FIRST" == b && "LAST" == c) return [e, Blockly.Solidity.ORDER_NONE];
        if (e.match(/^'?\w+'?$/) || d) {
            switch (b) {
                case "FROM_START":
                    d = Blockly.Solidity.getAdjusted(a, "AT1");
                    break;
                case "FROM_END":
                    d = Blockly.Solidity.getAdjusted(a, "AT1",
                        1, !1, Blockly.Solidity.ORDER_SUBTRACTION);
                    d = e + ".length - " + d;
                    break;
                case "FIRST":
                    d = "0";
                    break;
                default:
                    throw Error("Unhandled option (text_getSubstring).");
            }
            switch (c) {
                case "FROM_START":
                    a = Blockly.Solidity.getAdjusted(a, "AT2", 1);
                    break;
                case "FROM_END":
                    a = Blockly.Solidity.getAdjusted(a, "AT2", 0, !1, Blockly.Solidity.ORDER_SUBTRACTION);
                    a = e + ".length - " + a;
                    break;
                case "LAST":
                    a = e + ".length";
                    break;
                default:
                    throw Error("Unhandled option (text_getSubstring).");
            }
            b = e + ".slice(" + d + ", " + a + ")"
        } else {
            d = Blockly.Solidity.getAdjusted(a,
                "AT1");
            a = Blockly.Solidity.getAdjusted(a, "AT2");
            var f = Blockly.Solidity.text.getIndex_,
                g = {FIRST: "First", LAST: "Last", FROM_START: "FromStart", FROM_END: "FromEnd"};
            b = Blockly.Solidity.provideFunction_("subsequence" + g[b] + g[c], ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + ("FROM_END" == b || "FROM_START" == b ? ", at1" : "") + ("FROM_END" == c || "FROM_START" == c ? ", at2" : "") + ") {", "  var start = " + f("sequence", b, "at1") + ";", "  var end = " + f("sequence", c, "at2") + " + 1;", "  return sequence.slice(start, end);",
                "}"]) + "(" + e + ("FROM_END" == b || "FROM_START" == b ? ", " + d : "") + ("FROM_END" == c || "FROM_START" == c ? ", " + a : "") + ")"
        }
        return [b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_changeCase = function (a) {
        var b = {UPPERCASE: ".toUpperCase()", LOWERCASE: ".toLowerCase()", TITLECASE: null}[a.getFieldValue("CASE")];
        a = Blockly.Solidity.valueToCode(a, "TEXT", b ? Blockly.Solidity.ORDER_MEMBER : Blockly.Solidity.ORDER_NONE) || "''";
        return [b ? a + b : Blockly.Solidity.provideFunction_("textToTitleCase", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(str) {", "  return str.replace(/\\S+/g,", "      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});",
            "}"]) + "(" + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_trim = function (a) {
        var b = {
            LEFT: ".replace(/^[\\s\\xa0]+/, '')",
            RIGHT: ".replace(/[\\s\\xa0]+$/, '')",
            BOTH: ".trim()"
        }[a.getFieldValue("MODE")];
        return [(Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_MEMBER) || "''") + b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_print = function (a) {
        return "window.alert(" + (Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_NONE) || "''") + ");\n"
    };
    Blockly.Solidity.text_prompt_ext = function (a) {
        var b = "window.prompt(" + (a.getField("TEXT") ? Blockly.Solidity.quote_(a.getFieldValue("TEXT")) : Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_NONE) || "''") + ")";
        "NUMBER" == a.getFieldValue("TYPE") && (b = "Number(" + b + ")");
        return [b, Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_prompt = Blockly.Solidity.text_prompt_ext;
    Blockly.Solidity.text_count = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_NONE) || "''";
        a = Blockly.Solidity.valueToCode(a, "SUB", Blockly.Solidity.ORDER_NONE) || "''";
        return [Blockly.Solidity.provideFunction_("textCount", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle) {", "  if (needle.length === 0) {", "    return haystack.length + 1;", "  } else {", "    return haystack.split(needle).length - 1;", "  }", "}"]) + "(" + b + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_replace = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_NONE) || "''",
            c = Blockly.Solidity.valueToCode(a, "FROM", Blockly.Solidity.ORDER_NONE) || "''";
        a = Blockly.Solidity.valueToCode(a, "TO", Blockly.Solidity.ORDER_NONE) || "''";
        return [Blockly.Solidity.provideFunction_("textReplace", ["function " + Blockly.Solidity.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle, replacement) {", '  needle = needle.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,"\\\\$1")',
            '                 .replace(/\\x08/g,"\\\\x08");', "  return haystack.replace(new RegExp(needle, 'g'), replacement);", "}"]) + "(" + b + ", " + c + ", " + a + ")", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.text_reverse = function (a) {
        return [(Blockly.Solidity.valueToCode(a, "TEXT", Blockly.Solidity.ORDER_MEMBER) || "''") + ".split('').reverse().join('')", Blockly.Solidity.ORDER_FUNCTION_CALL]
    };
    Blockly.Solidity.variables = {};
    Blockly.Solidity.variables_get = function (a) {
        return [Blockly.Solidity.nameDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.Solidity.ORDER_ATOMIC]
    };
    Blockly.Solidity.variables_set = function (a) {
        var b = Blockly.Solidity.valueToCode(a, "VALUE", Blockly.Solidity.ORDER_ASSIGNMENT) || "0";
        return Blockly.Solidity.nameDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) + " = " + b + ";\n"
    };
    Blockly.Solidity.variablesDynamic = {};
    Blockly.Solidity.variables_get_dynamic = Blockly.Solidity.variables_get;
    Blockly.Solidity.variables_set_dynamic = Blockly.Solidity.variables_set;
    return Blockly.Solidity;
}));


//# sourceMappingURL=Solidity_compressed.js.map
